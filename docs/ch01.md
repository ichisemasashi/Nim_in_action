# なぜNimなのか？

  この章では
  - Nimとは？
  - なぜNimを学ぶ必要があるのか
  - Nimと他のプログラミング言語との比較 
  - 使用例
  - 長所と短所

Nimはまだ比較的新しいプログラミング言語です。実際、あなたが手にしているのは、Nimについて書かれた最初の本のひとつです。言語はまだ完全には完成していませんが、構文、プロシージャのセマンティクス、メソッド、イテレータ、ジェネリックス、テンプレートなど、核となる部分はすべて確立されています。その新しさにもかかわらず、Nim が実装しているユニークな機能やユーザーに提供している機能のおかげで、プログラミングコミュニティからは大きな関心が寄せられています。

本章では、なぜNimを使うのかといった、Nimを学ぶ前の疑問に答えます。この章では、Nim の一般的な使用方法、他のプログラミング言語との比較、Nim の長所と短所について説明します。

## 1.1 Nimとは何ですか？

Nimは、効率的で、表現力があり、エレガントであることを目指して設計された汎用プログラミング言語です。この3つの目標を同時に達成するのは難しいので、Nimの設計者はそれぞれに異なる優先順位をつけ、効率性を最も重視し、エレガントさを最も重視しませんでした。

しかし、エレガントさはNimのデザインにとって比較的重要ではないにもかかわらず、デザインプロセスの中で考慮されています。そのため、言語はそれ自体がエレガントであると言えます。効率とエレガントさの間でトレードオフが必要な場合にのみ、効率が優先されるのです。

表面的には、NimはPythonの特徴を多く共有しています。特に、Nimの構文の多くの側面はPythonに似ており、スコープを区切るためにインデントを使用したり、特定の演算子に記号ではなく単語を使用する傾向があります。また、NimはPythonと構文以外の面でも共通しており、例えば、ここで紹介しているように、非常にユーザーフレンドリーな例外トレースバックを採用しています。

```
Traceback (most recent call last)
request.nim(74)          request
request.nim(25)          getUsers
json.nim(837)            []
tables.nim(147)          []
Error: unhandled exception: key not found: totalsForAllResults [KeyError]
```

また、特に言語のセマンティクスに関しては、多くの違いが見られます。主な違いは、型システムと実行モデルにあり、次のセクションで説明します。

  **Nimの歴史を少し紹介します**
    Andreas Rumpf氏がNimの開発を始めたのは2005年のことでした。このプロジェクトはすぐにオープンソースコミュニティからの支持と多くの貢献を得て、世界中の多くのボランティアがGitHubのプルリクエストを通じてコードを提供しています。現在のオープンなNimのプルリクエストは、https://github.com/nim-lang/Nim/pulls で見ることができます。

  **NIMへの貢献** コンパイラ、標準ライブラリ、および関連ツールはすべてオープンソースで、Nimで書かれています。このプロジェクトはGitHubで公開されており、誰でも貢献することができます。Nim に貢献することは、Nim がどのように動作するかを学び、その開発を支援する良い方法です。詳細はNimのGitHubページを参照してください： https://github.com/nim-lang/Nim#contributing.

### 1.1.1 使用例

Nimは、最初から汎用的なプログラミング言語として設計されています。そのため、どのようなソフトウェアプロジェクトにも対応できるよう、幅広い機能を備えています。そのため、ウェブアプリケーションからカーネルまで、さまざまなアプリケーション領域のソフトウェアを書くのに適しています。このセクションでは、いくつかのユースケースにおいて、Nimの機能とプログラミングサポートがどのように適用されるかを説明します。

Nim は実質的にあらゆるアプリケーション・ドメインをサポートしていますが、だからといってすべてに適しているわけではありません。この言語のある側面は、他のアプリケーションよりもいくつかのカテゴリーに適しています。これは、Nimを使って書けないアプリケーションがあるということではなく、Nimが、ある種のアプリケーションを書くのに最適なコードスタイルをサポートしていない可能性があるということです。

Nim はコンパイルされた言語ですが、そのコンパイルの方法は特別です。Nim のコンパイラは、ソースコードをコンパイルする際に、まず C コードに変換します。C言語は古くからサポートされているシステムプログラミング言語で、マシンの物理的なハードウェアへのアクセスをより簡単に、よりダイレクトに行うことができます。このため、Nimはシステムプログラミングに適しており、オペレーティングシステム（OS）、コンパイラ、デバイスドライバ、組み込みシステムソフトウェアなどのプロジェクトを記述することができます。

インターネットに接続された電子機器であるIoT（Internet of Things）デバイスは、Nimの使いやすさとシステムプログラミング能力の高さから、Nimの格好のターゲットとなっています。

Nimのシステムプログラミング機能を利用したプロジェクトの好例として、NimKernelという非常にシンプルなOSがあります。GitHubで公開されています。https://github.com/dom96/nimkern

  **Nimはどのようにソースコードをコンパイルしているのか** Nimの変わったコンパイルモデルとその利点については、1.1.3項で詳しく説明しています。

Nimで書かれたアプリケーションは非常に高速で、多くの場合、C言語で書かれたアプリケーションと同じくらい、Pythonで書かれたアプリケーションの13倍以上の速さです。効率性を最優先し、コードの最適化を容易にする機能もあります。また、ソフトリアルタイムガベージコレクタでは、メモリの収集に費やす時間を指定することができます。通常のガベージコレクタでは、メモリの回収に時間をかけすぎると画面上のフレームの描画が遅くなってしまうため、ゲーム開発ではこの機能が重要になります。また、非常に厳密な時間軸で動作する必要のあるリアルタイムシステムにも有効である。

Nimは、パフォーマンスが重要なコンポーネントを高速化するために、他の低速な言語と一緒に使用することができます。例えば、Rubyで書かれたアプリケーションで、CPUに負荷のかかる計算を必要とするものを、部分的にNimで書くことで、かなりのスピードアップを図ることができます。このような高速化は、科学技術計算や高速取引などの分野で重要です。

また、ファイルの読み込みやネットワーク経由でのデータ送信など、I/O処理を行うアプリケーションもNimに対応しています。例えば、Webアプリケーションは、Jester（https://github .com/dom96/jester）のような多くのWebフレームワークを使って簡単に書くことができます。Nimのスクリプトのような構文と、強力な非同期I/Oのサポートにより、これらのアプリケーションを迅速に開発することができます。

コマンドラインアプリケーションは、Nimの効率性から大きな恩恵を受けることができます。また、Nimアプリケーションはコンパイルされているため、スタンドアロンであり、大規模なランタイムの依存関係を必要としません。そのため、非常に簡単に配布することができます。Nim で書かれたアプリケーションの一つに Nimble があります。これは Nim のパッケージマネージャで、ユーザは Nim のライブラリやアプリケーションをインストールすることができます。

これらは、Nimが適している使用例のほんの一部であり、すべてを網羅しているわけではありません。

また、この記事を書いている時点では、Nimはまだバージョン1.0に達しておらず、開発途上であることも覚えておいてください。まだ実装されていない機能があるため、用途によってはNimに適さない場合もあります。例えば、Nim には、Nim で Web ページ用の JavaScript アプリケーションを書くことができるバックエンドがあります。このバックエンドは動作しますが、言語の他の部分と比べてまだ成熟していません。これは時間とともに改善されるでしょう。

もちろん、NimはJavaScriptにコンパイルできるので、サーバー上やブラウザ上で動作するコンポーネントを必要とするフルスタックアプリケーションに適しています。アプリケーションのブラウザとサーバーの両方のコンポーネントにコードを簡単に再利用できるので、これは非常に大きな利点です。

さて、Nimとは何か、その歴史、そしてNimが特に適しているアプリケーションについて少し理解したところで、Nimの機能とその仕組みについて見ていきましょう。

### 1.1.2 コアな機能

Nimは多くの点で非常に革新的です。Nim の機能の多くは、他のプログラミング言語には見られないものです。新しいプログラミング言語を学ぶのが好きな方、特に面白くてユニークな機能を持つ言語を学びたい方には、Nim は間違いなくお勧めの言語です。

このセクションでは、Nim の中核的な機能、特に他のプログラミング言語と比べて Nim を際立たせている機能を紹介します。

- ニーズに合わせて言語を形成するために使用されるメタプログラミングと呼ばれる機能。
- スタイルインセンシティブな変数名、関数名、型名。この機能を使うと、識別子が `camelCase` や `snake_case` で定義されていても、好きなスタイルで扱うことができますが、これは少し議論の余地があります。
- 型システムにはジェネリックなどの機能が充実しており、コードの作成や保守が容易になります。
- C言語へのコンパイルにより、Nimのプログラムは効率的でポータブルになります。また、コンパイル自体も非常に高速です。
- 様々な種類のガベージコレクターがあり、自由に選択したり、完全に削除することができます。

#### メタプログラミング

Nimの最も実用的で、ある意味でユニークな機能は、広範なメタプログラミングのサポートです。メタプログラミングでは、ソースコードの読み取り、生成、分析、変換を行うことができます。これは決してNimの発明ではありませんが、Nimのように広範囲で同時に簡単に使えるメタプログラミングを備えたプログラミング言語は他にありません。もしあなたがLispに慣れ親しんでいるのであれば、すでにメタプログラミングを経験しているかもしれません。

メタプログラミングでは、コードを抽象的な構文木の形をしたデータとして扱います。これにより、アプリケーションのコンパイル中に、既存のコードを操作したり、まったく新しいコードを生成したりすることができます。

Nimのメタプログラミングが特別なのは、メタプログラミングの機能が充実している言語がLisp系の言語に属しているからです。もしあなたがJavaやPythonに慣れ親しんでいるのであれば、LispよりもNimの方が簡単に使い始めることができるでしょう。また、LispよりもNimのメタプログラミング機能の使い方を学ぶ方が自然だと思います。

一般的には上級者向けのトピックですが、メタプログラミングは非常に強力な機能で、本書の第9章ではその詳細を知ることができます。メタプログラミングがもたらす主な利点の1つは、定型的なコードを取り除くことができることです。また、メタプログラミングによって、ドメイン固有の言語（DSL）を作成することができます。

```
html:
  body:
    p: "Hello World"
```

このDSLは、ちょっとしたHTMLコードを指定するものです。実装方法にもよりますが、このDSLは以下のようなNimコードに翻訳されるようです。

```
echo("<html>")
echo("  <body>")
echo("    <p>Hello World</p>")
echo("  </body>")
echo("</html>")
```

そのNimコードでは、以下のような出力になります。

```
<html>
  <body>
    <p>Hello World</p>
  </body>
</html>
```


Nimのメタプログラミングでは、DSLを定義して、通常のNimコードと自由に組み合わせることができます。このような言語には多くの使用例があります。例えば、先の例では、ウェブアプリケーションのHTMLテンプレートを作成するのに使用できます。

メタプログラミングは、Nimのデザインの中心にあります。Nimの設計者は、ユーザーのプログラミングのスタイルに合わせて、メタプログラミングの使用を奨励したいと考えています。例えば、Nimにはオブジェクト指向プログラミング（OOP）の機能がありますが、クラス定義の仕組みはありません。その代わり、他の言語と同じようなスタイルでNimでOOPを使用したい場合は、メタプログラミングを使用してそのような構造を作成する必要があります。

#### スタイル不感症

Nimのもう一つの興味深い特徴は、スタイル不感症です。プログラマーが最も苦労することの一つは、変数、関数、モジュールなど、様々な識別子の名前を考えることです。多くのプログラミング言語では、これらの名前には空白を含めることができないため、プログラマは1つの名前の中で複数の単語を分離する別の方法を採用せざるを得ませんでした。複数の異なる方法が考案されましたが、最も人気があるのは `snake_case` と `camelCase` です。Nimでは、識別子が`camelCase`で定義されていても、`snake_case`を使うことができますし、その逆も可能です。つまり、使用しているライブラリが識別子に異なるスタイルを採用していても、自分の好きなスタイルでコードを書くことができるのです。

```
Listing 1.1 スタイル不感症
import strutils   <--- strutilsモジュールでは、toUpperという手続きが定義されています。
echo("hello".to_upper()) <--- snake_caseを使って呼び出すことができます。
echo("world".toUpper())  <--- 元々の定義通り、camelCaseを使って呼び出すことができます。
```

これは、Nim が識別子の to_upper と toUpper を同じと見なすためです。識別子を比較するとき、Nim は最初の文字の大文字/小文字を考慮しますが、識別子の残りの文字の大文字/小文字は気にせず、アンダースコアも無視します。その結果、最初の文字の大文字と小文字が異なるため、toUpper と ToUpper という識別子は同じではありません。これにより、型名と変数名を区別することができます。

型名は大文字で始まり、変数名は小文字で始まるのが慣例だからです。次のリストは、この規則が役立つシナリオの1つです。

```
Listing 1.2 スタイル不感症とタイプ識別子
type
  Dog = object  <--- Dogのtypeは大文字の最初の文字で定義されます。
    age: int  <--- 小文字で始まるのはintなどのプリミティブ型だけです。
let dog = Dog(age: 3)  <--- dog変数はDog型と衝突しないので安心して定義できます。
```

#### 強力な型システム

プログラミング言語を差別化する多くの特徴の1つに、型システムがあります。型システムの主な目的は、プログラムにバグが発生する機会を減らすことです。他にも、優れた型システムは、コンパイラの最適化や、コードの文書化を容易にするなどの利点があります。

型システムの分類には、主に静的型と動的型があります。ほとんどのプログラミング言語は、この2つの両極端の間に位置し、両方のアイデアを取り入れています。これは、静的型付けも動的型付けも、ある種のトレードオフを必要とするからである。静的型付けは、コンパイル時に多くのエラーを発見しますが、プログラムを書く速度を低下させてしまいます。動的型付けはその逆です。

Nim は静的型付けされていますが、他の静的型付けされたプログラミング言語とは異なり、開発を高速化するための多くの機能が組み込まれています。型推論はその良い例で、型を自分で書かなくても、コンパイラが型を解決してくれます（自分で選ぶこともできますが）。そのため、バグのないプログラムを作ることができ、なおかつ開発速度も妨げられません。また、Nimには、ランタイム型情報などの動的な型チェック機能が搭載されており、関数の動的なディスパッチが可能になっています。

型システムがプログラムにバグがないことを保証する方法の一つに、メモリの安全性を検証することがあります。C言語のように、割り当てられていないメモリにプログラムがアクセスできるため、メモリセーフではないプログラミング言語もあります。他のプログラミング言語は、プログラムがメモリの低レベルの詳細にアクセスできないという代償を払ってメモリセーフを実現していますが、場合によっては必要なこともあります。プログラムの中で `ptr` などの安全ではない型を使わない限り、Nim はメモリセーフですが、`ptr` 型は C ライブラリとの連携に必要です。これらの安全でない機能をサポートすることで、Nim は強力なシステムプログラミング言語となります。

デフォルトでは、Nim はあらゆる種類のメモリエラーから保護してくれます。

- 配列はコンパイル時に境界チェックが行われ、コンパイル時にチェックができない場合はランタイムにチェックが行われます。
- 参照型は、Nim のガベージコレクタによって完全に管理されるため、ポインタ演算はできません。これにより、ダングリングポインタなどの問題や、手動でメモリを管理することに関連するメモリ問題を防ぐことができます。
- また、変数は常に Nim によってデフォルト値に初期化されるため、変数に予期せぬ不正なデータが含まれることもありません。

最後に、Nim の型システムの最も重要な機能の 1 つは、ジェネリック プログラミングを使用できることです。Nim のジェネリックは、型の安全性を犠牲にすることなく、コードを大幅に再利用することができます。特に、一つの関数が複数の異なる型を受け入れることができるように指定することができます。例えば、画面に整数と浮動小数点の両方を表示する`showNumber`プロシージャがあるとします。

```
proc showNumber(num: int | float) =
  echo(num)
showNumber(3.14)
showNumber(42)
```

ここで，`showNumber`プロシージャは，`int`型か`float`型のどちらかを受け取ります。`|`演算子は、`int`と`float`の両方をプロシージャに渡すことができることを指定しています。
これは Nim のジェネリックの簡単なデモンストレーションです。Nim の型システムやジェネリックについては、後の章でもっと詳しく説明します。

#### コンピレーション

前の章で、Nim コンパイラはソースコードをまず C にコンパイルし、そのソースコードを C コンパイラに供給すると述べました。この仕組みについては1.1.3節で詳しく説明しますが、ここではこのコンパイルモデルの多くの実用的な利点について説明します。

C言語はシステムプログラミング言語として非常に定評があり、40年以上も使用されています。Windows、Linux、Mac OS、x86、AMD64、ARMなど、さまざまなOSやプラットフォームに対応しており、最も移植性の高いプログラミング言語の1つです。C言語のコンパイラは、スーパーコンピュータからマイクロコントローラまで、あらゆる機器に対応しています。また、非常に成熟しており、多くの強力な最適化機能が実装されているため、C言語は非常に効率的です。

Nimは、このような移植性、普及性、効率性といったC言語の特徴を活かしています。

C言語にコンパイルすることで、既存のCやC++のライブラリを簡単に利用することができます。必要なのは簡単なラッパーコードを書くことだけです。このコードは、c2nimというツールを使えば、より早く書くことができます。このツールは、CやC++のヘッダーファイルをNimコードに変換し、それらのファイルをラップしてくれます。人気のあるライブラリの多くはCやC++で書かれているので、これは大きなメリットです。

また、Nimには、CやC++と互換性のあるライブラリを構築する機能もあります。これは、自分のライブラリを他のプログラミング言語から使用したい場合に便利です。C と C++ のライブラリのラッピングについては、第 8 章で詳しく説明します。

Nim のソースコードは、Objective C や JavaScript にコンパイルすることもできます。Objective C 言語は、主に iOS ソフトウェアの開発に使用されており、これにコンパイルすることで、Nim でネイティブに iOS アプリケーションを作成することができます。また、C++のコンパイルバックエンドを使うことで、Nimを使ってAndroidアプリケーションを開発することもできます。JavaScriptは、何十億ものウェブサイトで使用されているクライアントサイドの言語です。主要なウェブブラウザのすべてでサポートされている唯一のプログラミング言語であるため、「ウェブのアセンブリ言語」と呼ばれることもあります。JavaScriptにコンパイルすることで、Webブラウザ用のクライアントサイドアプリケーションをNimで書くことができます。図1.1に、利用可能なNimのバックエンドを示します。

Nimのコンパイルの速さが気になるところです。Nimはソースコードを中間言語に変換する必要があるので、とても遅いと思っているかもしれません。しかし、実際にはかなり速いのです。例えば、約10万行のNimコードで構成されたNimコンパイラーは、2.7GHzのIntel Core i5 CPUを搭載したMacBook Proで、約12秒でコンパイルできます。各コンパイルはキャッシュされるため、最初のコンパイル後は5秒にまで短縮されます。

![fig1.1](../pic/fig_1_1.png)
Figure 1.1 Compilation backends

#### メモリ管理

C と C++ では、メモリを手動で管理する必要があり、割り当てたメモリが不要になったら確実に解放されるように注意する必要があります。一方、Nim はガベージコレクタを使ってメモリを管理してくれます。しかし、ガベージコレクタは、組み込みシステムやゲームなど、特定のアプリケーション領域では不十分だと言われており、避けたい場合もあります。そのため、Nim では、用途に応じてさまざまなガベージコレクタをサポートしています。また、ガベージコレクタを完全に削除して、自分でメモリを管理することも可能です。

  **GARBAGE COLLECTORS** ガベージコレクタの切り替えは簡単です。コンパイル時に `--gc:<gc_name>` フラグを指定し、`<gc_name>` を `markandsweep`, `boehm`, または `none` に置き換えるだけです。

これは、Nimの最も重要な機能のほんの一部に過ぎません。ユニークで革新的な機能だけでなく、既存のプログラミング言語の機能を独自に組み合わせて、Nim全体を非常にユニークなものにしているものもあります。

### 1.1.3 Nimの仕組みは？

Nimの特徴の一つは、その実装にあります。すべてのプログラミング言語には、ソースコードをインタープリットしたり、ソースコードをコンパイルして実行ファイルにしたりする、アプリケーションの形をした実装があります。これらの実装をそれぞれインタープリタ、コンパイラと呼びます。言語によっては複数の実装がある場合もありますが、Nim の実装はコンパイラのみです。コンパイラは、Nim のソースコードを、別のプログラム言語である C に翻訳し、その C のソースコードを C コンパイラに渡して、バイナリの実行ファイルにコンパイルします。実行ファイルには、Nimのソースコードで指定されたタスクを含め、コンピュータが実行すべき具体的なタスクを示す命令が含まれています。図1.2は、Nimのソースコードが実行ファイルにコンパイルされる様子を示しています。

ほとんどのプログラミング言語のコンパイラには、このような余分なステップはなく、ソースコードを自分でコンパイルして実行可能なバイナリにします。また、ソースコードをコンパイルしないものもあります。図1.3は、さまざまなプログラミング言語がソースコードを実行可能なものに変換する様子を示しています。

![fig1.2](../pic/fig_1_2.png)
Figure 1.2 Nimがソースコードをコンパイルする仕組み

![fig1.3](../pic/fig_1_3.png)
Figure 1.3 Nimのコンパイルプロセスと他のプログラミング言語との比較

Nimは、生成されたCソースコードをコンパイルするために、Cコンパイルプロセスに接続します。つまり、Nimのコンパイラは、GCCやClangなどの外部のCコンパイラに依存することになります。コンパイルの結果は、コンパイルされたCPUアーキテクチャやOSに特化した実行ファイルとなります。

これで、Nim のソースコードがどのようにして実用的なアプリケーションに変換されるのか、また、このプロセスが他のプログラミング言語で使用されるものとどのように異なるのか、よく理解できると思います。Nim のソースコードに変更を加えるたびに、再コンパイルする必要があります。
では、Nimの良い点と悪い点を見ていきましょう。


## 1.2 Nimの長所と短所

ある言語を使いたいと思う理由を理解することは重要ですが、その言語が特定の使用ケースに適していないかもしれない理由を知ることも同様に重要です。

このセクションでは、Nimを他の多くのプログラミング言語と比較し、そのような比較によく使われるさまざまな特徴や要因に注目します。その上で、Nimが他の言語に追いつくために必要な分野についても述べます。

### 1.2.1 メリット

この本を読んでいると、Nimと今まで使っていたプログラミング言語との比較が気になるかもしれません。言語の実行速度、表現力、開発速度、読みやすさ、エコシステムなど、比較するためには様々な要素があります。ここでは、これらの要素をいくつか見て、Nimのメリットを考えてみましょう。

#### nimは効率的

プログラミング言語で書かれたアプリケーションの実行速度は、よく比較に使われます。Nimの目標の一つは効率性ですから、Nimが非常に効率的なプログラミング言語であることは当然のことです。

C は最も効率的なプログラミング言語の 1 つであるため、Nim との比較が気になるかもしれません。前のセクションでは、Nim コンパイラがまず Nim コードを中間言語に変換することを学びました。デフォルトでは中間言語はC言語になっているので、NimのパフォーマンスはC言語に近いのではないかと思われますが、その通りです。

この機能のおかげで、Nim は C の完全な代替品として使用することができます。

- NimはC言語と同等の性能を持っています。
- Nimは、C言語で書かれたソフトウェアよりも信頼性の高いソフトウェアを実現します。
- Nim は改良された型システムを備えています。
- Nim はジェネリックをサポートしています。
- Nim は先進的なメタプログラミングを実装しています。

C言語と比較して、Nimのメタプログラミングはユニークで、プリプロセッサを使用せず、メインのコンパイルプロセスの一部となっています。一般的に、NimにはC言語にはない多くの最新機能が期待できるため、C言語の代替としてNimを選択することには大きな意味があります。

表1.1に小さなベンチマークテストの結果を示します(*1)。NimはC言語の速度に匹敵し、Pythonよりもかなり速いです。

Table 1.1 0から1億までの数字の中で、どの数字が素数かを見つけるのにかかった時間

| Programming language | Time (seconds) |
|:---------------------|:---------------|
| C                    | 2.6            |
| Nim                  | 2.6            |
| Python(CPython)      | 35.1           |

このベンチマークでは、NimアプリケーションのランタイムはC言語のアプリの速度と一致し、Pythonで実装されたアプリよりも大幅に高速になっています。このようなマイクロベンチマークは信頼性に欠けることが多いのですが、代わりになるものはあまりありません。Nimのパフォーマンスは、すでに最も効率的なプログラミング言語の1つであるC言語のパフォーマンスに匹敵します。

#### NIMは読みやすい

Nim は非常に表現力豊かな言語であるため、コンパイラにとっても人間の読者にとっても分かりやすい Nim のコードを簡単に書くことができます。Nim のコードには、JavaScript や C++ などの C ライクなプログラミング言語に見られるような中括弧やセミコロンはなく、Ruby などの言語に見られるような do や end キーワードも必要ありません。
この表現力豊かな Nim のコードと、表現力の低い C++ のコードを比較してみましょう。

```
Listing 1.3 Nimでの0から9への反復処理
for i in 0 .. <10:
  echo(i)
```

```
Listing 1.4 C++での0から9への反復処理
#include <iostream>
using namespace std;
int main() {
   for (int i = 0; i < 10; i++)
   {
       cout << i << endl;
   }
return 0; }
```

Nim のコードはより読みやすく、はるかにコンパクトになっています。C++のコードには、Nimでは省略可能な要素が多く含まれています。例えば、main関数の宣言は、Nimでは完全に暗黙の了解となっています。

Nim は書くのが簡単ですが、それ以上に重要なのは、読むのも簡単だということです。コードの読みやすさは非常に重要です。例えば、デバッグがしやすくなるので、美しいNimのコードを書くことに時間を割くことができ、開発期間を短縮することができます。

#### nimは独立している

これはすでに述べたことですが、他の言語との比較や、特にランタイムを必要とする言語がある理由を説明するために、もう一度説明する価値があります。

Nim、C、Go、D、Rust などのコンパイルされたプログラミング言語は、コンパイラーが動作している OS のネイティブな実行ファイルを生成します。NimアプリケーションをWindowsでコンパイルすると、Windowsでしか実行できない実行ファイルができあがります。同様に、Mac OS でコンパイルした場合は、Mac OS でしか実行できない実行ファイルが作成されます。また、CPUのアーキテクチャも関係してきます。ARMでコンパイルすると、ARMのCPUにしか対応していない実行ファイルができあがります。初期設定ではこのようになっていますが、クロスコンパイルといって、異なるOSとCPUの組み合わせで実行ファイルをコンパイルするようにNimに指示することも可能です。

クロスコンパイルは、目的のアーキテクチャやOSを搭載したコンピューターがない場合や、コンパイルに時間がかかりすぎる場合に使用します。一般的な使用例としては、CPUの処理速度が遅いRaspberry PiなどのARMデバイス用にコンパイルする場合が挙げられます。クロスコンパイルの詳細については、Nim Compiler User Guide: http://nim-lang.org/docs/nimc.html#cross-compilation を参照してください。

とりわけ、JVMはクロスコンパイルの必要性をなくすために作られました。"write once, run anywhere "という言葉を聞いたことがあるかもしれません。Sun Microsystemsは、Javaのクロスプラットフォームの利点を説明するために、このスローガンを作りました。Javaアプリケーションは一度だけコンパイルする必要があり、その結果、コンパイルされたすべてのJavaクラスを格納したJARファイルが作成されます。このJARファイルは、JVMによって実行され、あらゆるプラットフォームやアーキテクチャ上でプログラムされた動作を行うことができます。これにより、JARファイルはプラットフォームやアーキテクチャに依存しない実行ファイルとなります。欠点は、これらのJARファイルを実行するためには、ユーザーのシステムにJVMがインストールされていなければならないことです。JVMは非常に大きな依存関係にあり、バグやセキュリティ問題を含んでいる可能性があります。しかしその一方で、Javaアプリケーションを一度だけコンパイルすることが可能になります。

Python、Ruby、Perlも同様です。これらはコードの実行に仮想マシン(VM)を使用しています。Pythonの場合、VMはPythonコードの実行を最適化するために使用されますが、ほとんどはPythonインタープリタの実装の詳細として隠されています。Pythonインタープリタはコードを解析し、そのコードがどのようなアクションを記述しているかを判断し、即座にそのアクションを実行します。JavaやC、Nimのようなコンパイルのステップはありません。クロスコンパイルの必要はありませんが、Pythonアプリケーションを実行するためには、システムにPythonインタープリタがインストールされている必要があります。

  **Write once, run anywhere**（一度書けばどこでも実行できる
  Write once, run anywhere "のスローガンと同様に、他のプログラミング言語も "Write once, compile anywhere "の理念を採用していた。これは、C言語、Pascal、Adaなどの言語に当てはまります。しかし、これらの言語では、新しいスレッドを作成したり、Webページの内容をダウンロードしたりするなど、OSのより特殊な機能を扱う際には、プラットフォーム固有のコードが必要になります。Nimは、さらにその上を行く、OSの違いを抽象化した標準ライブラリを持っているので、現代のOSが提供する多くの機能を利用することができます。

残念ながら、多くの場合、仮想マシンやインタプリタは、解決するよりも問題を引き起こすことが多いのです。一般的なCPUアーキテクチャや最も普及しているOSの数はそれほど多くないため、それぞれに合わせてコンパイルすることはそれほど難しくありません。一方、インタプリタ言語で書かれたアプリケーションのソースコードはユーザーに配布されることが多く、ユーザーは正しいバージョンのインタプリタや仮想マシンをインストールすることになります。そのため、様々な問題が発生します。

このようなアプリケーションの配布の難しさの一例として、最近登場したPython 3が挙げられます。前のバージョンとの下位互換性がないため、もともとPython 2で書かれたソフトウェアに多くの問題を引き起こしました。2008年にリリースされたPython 3ですが、この記事を書いている時点では、Python 2用に書かれたライブラリがPython 3のインタープリタでは動作しないものがあります(*2)。

Nimの軽量性は、このセクションで述べたいくつかの言語とは対照的に、特に魅力的であるはずです。

#### nimはフレキシブル

ソフトウェアの書き方には様々なスタイルがあります。プログラミングパラダイムとは、ソフトウェアを書くための基本的なスタイルのことで、各プログラミング言語はそれぞれ異なるパラダイムをサポートしています。少なくとも、オブジェクト指向プログラミング（OOP）については、多くのコンピュータサイエンスのコースで教えられていますので、ご存知の方も多いでしょう。

Nimは、マルチパラダイムのプログラミング言語です。人気のあるプログラミング言語とは異なり、Nim は OOP パラダイムを重視していません。主に手続き型のプログラミング言語であり、OOP、関数型、宣言型、並行型、その他のプログラミングスタイルをさまざまにサポートしています。

しかし、OOPがサポートされていないというわけではありません。プログラミングスタイルとしてのOOPは、強制されることはありません。Nim は、継承、ポリモーフィズム、動的ディスパッチなど、一般的な OOP 機能をサポートしています。

Nim の主要なパラダイムがどのようなものかを理解していただくために、OOP パラダイムと手続き型パラダイムの大きな違いを見てみましょう。OOPパラダイムでは、メソッドや属性はオブジェクトに束縛されており、メソッドは独自のデータ構造を操作します。手続き型のパラダイムでは、手続きはデータ構造上で動作する独立したエンティティです。これはイメージしにくいかもしれませんので、いくつかのコード例を見て説明しましょう。

**SUBROUTINE TERMINOLOGY** このサブセクションでは、メソッドとプロシージャについて触れます。これらは単にサブルーチンや関数の異なる名称です。メソッドはOOPの文脈で使われる用語で、プロシージャは手続き型プログラミングで、関数は関数型プログラミングで使われます。

以下のコードリストは、同じアプリケーションを示しています。最初のコードは、PythonでOOPスタイルで書かれています。2つ目はNimで書かれており、手続き型のスタイルです。

```
Listing 1.5 PythonのOOPで吠える犬をモデル化
class Dog:
  def bark(self): <--- (1)
    print("Woof!")
dog = Dog()
dog.bark() <--- (2)
```
1. barkメソッドは、Dogクラスの中で定義されているため、Dogクラスに関連付けられています。
2. barkメソッドは、dotを介してメソッドにアクセスすることで、dogオブジェクト上で直接呼び出すことができます。

```
Listing 1.6 Nimの手続き型プログラミングで吠える犬をモデル化
type
  Dog = object
proc bark(self: Dog) =  <--- (1)
  echo("Woof!")
let dog = Dog()
dog.bark()   <--- (2)
```
1. barkプロシージャは、Dogタイプの中で定義されているため、Dogタイプとは直接関係ありません。このプロシージャは、このモジュールの外で簡単に定義することもできます。
2. barkプロシージャは、Python版のようにDog型に関連付けられていないにもかかわらず、dogオブジェクトに直接呼び出すことができます。

Pythonのコードでは、barkメソッドはクラス定義の下に置かれています。Nimのコードでは、barkメソッド（Nimではプロシージャと呼ばれる）はPythonのコードと同じようにDog型に束縛されておらず、Dog型の定義とは独立しています。その代わり、第一引数で関連付けられている型を指定します。

同じようなことをPythonで実装することもできますが、それでは同じようにbarkメソッドを呼び出すことができません。bark(dog)のように、第1引数にdog変数を明示的に渡してメソッドを呼び出す必要があります。Nimでは、dog.bark()をbark(dog)に書き換えることで、クラスに明示的にバインドすることなく、伝統的なOOPスタイルでメソッドを呼び出すことができるようになります。

この機能は、UFCS（Uniform Function Call Syntax）と呼ばれ、複数の利点があります。既存のオブジェクトに対して外部から新しいプロシージャを作成することができ、プロシージャコールを連鎖させることができます。

**NIMのクラス** Nimでは、Pythonに似た方法でクラスやメソッドを定義することも可能です。これにはメタプログラミングが使用でき、コミュニティはすでにその構文をエミュレートした数多くのライブラリを作成しています。例えば、Nim の OOP マクロ: https://nim-by-example.github.io/oop_macro/ を参照してください。

Nim がサポートしているもう一つのパラダイムは、関数型プログラミング（FP）のパラダイムです。FPはOOPほど普及していませんが、近年人気が急上昇しています。FPは、主に状態の変化や変更可能なデータの使用を避けるプログラミングのスタイルです。Nimがサポートしているファーストクラス関数、無名関数、クロージャなどの機能を使用しています。

手続き型のプログラミングと関数型のプログラミングの違いについて、例を挙げて説明します。以下のコードリストは、人のフルネームを名字と名前に分離するコードです。リスト1.7は機能的なスタイルで、リスト1.8は手続き的なスタイルでこれを行っています。

```
Listing 1.7 Nimでの関数型プログラミングによる配列の反復処理
import sequtils, future, strutils <--- (1)
let list = @["Dominik Picheta", "Andreas Rumpf", "Desmond Hume"]  <--- (2)
list.map(  <--- (3)
  (x: string) -> (string, string) => (x.split[0], x.split[1])  <--- (4)
).echo  <--- (5)
```
1. sequtils, future, strutilsモジュールをインポートしています。これらのモジュールは、それぞれmap、->、split手続きを定義しています。
2. 名前のリストを含む新しいリスト変数を定義します。
3. map 手続きは、リストを反復処理するために使用されます。
4. mapプロシージャは、リストの各項目をどのように変更するかを指定するクロージャを受け取ります。
5. 変更されたリストが画面に表示されます。

```
Listing 1.8 Nimの手続き型スタイルによるシーケンスの反復処理
import strutils <--- (1)
let list = @["Dominik Picheta", "Andreas Rumpf", "Desmond Hume"]
for name in list: <--- (2)
  echo((name.split[0], name.split[1])) <--- (3)
```
1. split手続きを定義したstrutilsモジュールをインポートします。
2. リストの各項目を繰り返し処理するためにforループを使用しています。
3. for ループ内のコードは、各反復の間に実行されます。この場合、各名前は 2 つに分割され、タプルとして表示されます。

関数型バージョンでは、mapプロシージャを使用して、名前のリストが格納されているリスト変数を繰り返し処理します。手続き型では、forループを使用しています。どちらのバージョンでも、名前を名字と名前に分割します。そして、その結果をタプルで表示します。(新しい用語がたくさん出てきましたね。第2章で紹介しますので、知らなくても心配しないでください) コードリストの出力は以下のようになります。

```
(Field0: Dominik, Field1: Picheta)
(Field0: Andreas, Field1: Rumpf)
(Field0: Desmond, Field1: Hume)
```

**FIELD0とFIELD1の意味** Field0とField1は、フィールド名が指定されていないときにタプルに与えられるデフォルトのフィールド名です。

Nimは非常に柔軟で、様々なスタイルのソフトウェアを書くことができます。以上、Nimがサポートしている最も一般的なパラダイムと、それらとNimのメインパラダイムとの比較について、ほんの少しだけご紹介しました。Nim は、より一般的ではないパラダイムもサポートしており、メタプログラミングを使用して、他のパラダイムのサポートを簡単に導入することができます。

#### NIM CATCHES ERRORS AHEAD OF TIME

Throughout this chapter, I’ve been comparing Python to Nim. While Nim does take a lot of inspiration from Python, the two languages differ in one important way: Python is dynamically typed and Nim is statically typed. As a statically typed language, Nim provides a certain level of type safety that dynamically typed programming languages don’t provide.
Although Nim is statically typed, it feels very dynamic because it supports type inference and generics. You’ll learn more about these features later in the book. For now, think of it as a way to retain the high development speed that dynamically typed programming languages allow, while also providing extra type safety at compile time.
In addition to being statically typed, Nim implements an exception-tracking mechanism that is entirely opt-in. With exception tracking, you can ensure that a procedure won’t raise any exceptions, or that it will only raise exceptions from a predefined list. This prevents unexpected crashes by ensuring that you handle exceptions.

#### COMPARING DIFFERENT PROGRAMMING LANGUAGE FEATURES

Throughout this section, I’ve compared Nim to various other programming languages. I’ve discussed efficiency, the dependencies of the resulting software, the flexibility of the language, and the language’s ability to catch errors before the software is deployed. Based on these characteristics alone, Nim is an excellent candidate for replacing some of the most popular programming languages out there, including Python, Java, C, and more.
For reference, table 1.2 lists different programming languages and shows some of the features that they do and don’t support.

Table 1.2 Common programming language features
![table1.2](../pic/tab_1_2.png)

a Nim supports ref counting, a custom GC, and Boehm. Nim also allows the GC to be switched off altogether.
b Some very limited metaprogramming can be achieved via C’s preprocessor.
c C++ only offers metaprogramming through templates, limited CTFE (compile-time function execution), and no AST macros.
d Rust has some support for declarative macros through its macro_rules! directive, but no built-in procedural macros that allow you to transform the AST except for compiler plugins, and no CTFE.
e See the “Oracle JVM Garbage Collectors Available From JDK 1.7.0_04 And After” article on Fasterj: www.fasterj.com/ articles/oraclecollectors1.shtml.
f You can modify the behavior of functions, including manipulating their AST, using the ast module, but only at runtime. 
g Lua uses do and end keywords to delimit scope.

### 1.2.2 Areas where Nim still needs to improve

Nothing in this world is perfect, and programming languages are no exception. There’s no programming language that can solve every problem in the most reliable and rapid manner. Each programming language has its own strengths and weak- nesses, and Nim is no exception.
So far, I’ve been focusing on Nim’s strengths. Nim has many more fine aspects that I haven’t yet mentioned, and you’ll discover them throughout this book. But it would be unfair to only talk about Nim’s strengths. Nim is still a young programming language, so of course it can still improve.

#### NIM IS STILL YOUNG AND IMMATURE

All programming languages go through a period of immaturity. Some of Nim’s newer and more-advanced features are still unstable. Using them can result in buggy behavior in the compiler, such as crashes, though crashes don’t happen very often. Importantly, Nim’s unstable features are opt-in, which means that you can’t accidentally use them.
Nim has a package manager called Nimble. Where other programming languages may have thousands of packages available, Nim only has about 500. This means that you may need to write libraries for certain tasks yourself. This situation is, of course, improving, with new packages being created by the Nim community every day. In chapter 5, I’ll show you how to create your own Nimble packages.

#### NIM’S USER BASE AND COMMUNITY IS STILL QUITE SMALL

Nim has a small number of users compared to the mainstream programming languages. The result is that few Nim jobs exist. Finding a company that uses Nim in production is rare, but when it does happen, the demand for good Nim programmers can make the salaries quite high.
On the other hand, one of the most unique things about Nim is that its development is exceptionally open. Andreas Rumpf (Nim’s creator) and many other Nim developers (including me) openly discuss Nim’s future development plans on GitHub and on IRC. Anyone is free to challenge these plans and, because the community is still quite small, it’s easy to do so. IRC is also a great place for newcomers to ask questions about Nim and to meet fellow Nim programmers.

**IRC** Take a look at appendix A for details on how to connect to Nim’s IRC channel.

These problems are temporary. Nim has a bright future ahead of it, and you can help shape it. This book teaches you how.

## 1.3 Summary

Created by Andreas Rumpf in 2005, Nim is still a very new programming language; it hasn’t yet reached version 1.0. Because Nim is so new, it’s a bit immature and its user base is relatively small.
- Nim is efficient, expressive, and elegant (in that order).
- Nim is an open source project that’s developed entirely by the Nim community of volunteers.
- Nim is general-purpose programming language and can be used to develop anything from web applications to kernels.
- Nim is a compiled programming language that compiles to C and takes advantage of C’s speed and portability.
- Nim supports multiple programming paradigms, including OOP, procedural programming, and functional programming.


-----

1 You can read more about this benchmark test on Dennis Felsing’s HookRace blog: http://hookrace.net/ blog/what-is-special-about-nim/#good-performance.
2 See the Python 3 Readiness page for a list of Python 3–ready packages: http://py3readiness.org/.



